    // --- Audio Logic ---
    function initAudio() {
        if (!aCtx) {
            aCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = aCtx.createAnalyser(); 
            analyser.fftSize = 256; 
            data = new Uint8Array(analyser.frequencyBinCount);
        }
        
        // 核心修復：根據模式決定點樣處理音訊流
        if (!isBGStable) {
            // 精準模式：必須連接 source -> analyser -> destination 會有聲
            if (!source && player.src) {
                try {
                    source = aCtx.createMediaElementSource(player);
                    source.connect(analyser);
                    analyser.connect(aCtx.destination);
                    console.log("Precision Mode Active");
                } catch(e) { console.log(e); }
            }
        } else {
            // 穩定模式：如果之前有接過 source，一定要中斷佢，等音訊行返預設路徑
            if (source) {
                try {
                    source.disconnect();
                    source = null; 
                } catch(e) {}
            }
            console.log("Stable Mode Active (Default Output)");
        }
        loop();
    }

    // 當切換模式時，我哋重置播放狀態確保生效
    function toggleBGMode() {
        isBGStable = !isBGStable;
        document.getElementById('opt-bgmode').classList.toggle('active', isBGStable);
        document.getElementById('bgmode-status').innerText = isBGStable ? "ON" : "OFF";
        saveSettings();
        
        // 強制重置音訊接駁
        if (player.src) {
            const currentPos = player.currentTime;
            const isPaused = player.paused;
            
            // 斷開舊連接
            if (source) {
                try { source.disconnect(); } catch(e){}
                source = null;
            }
            
            // 重新載入以套用新路徑
            player.load();
            player.currentTime = currentPos;
            if (!isPaused) player.play().then(() => initAudio());
        }
    }

    document.getElementById('f').onchange = (e) => {
        const file = e.target.files[0]; if (!file) return;
        setLoading(true); switchPage('play', 0);
        if (player.src) URL.revokeObjectURL(player.src);
        player.src = URL.createObjectURL(file);
        titleTag.innerText = file.name; 
        const tx = db.transaction("devilLatest", "readwrite");
        tx.objectStore("devilLatest").put({ name: file.name, blob: file }, "latestTrack");
        
        // 選新歌時徹底重置
        if (source) { try{ source.disconnect(); }catch(ex){} source = null; }

        player.load(); 
        player.play().then(() => { 
            setLoading(false); 
            initAudio(); 
        }).catch(() => setLoading(false));
        processFileMetadata(file);
    };
